Hello and welcome

This talk is called "What more can I learn from my OpenTelemetry traces?"

My name is John Pruitt and I am an Engineer at Timescale

For roughly the last six months, I have been working with a small team of engineers to add support for OpenTelemetry traces to an open-source tool called Promscale.

To date, Promscale is probably best known as a backend storage for Prometheus using TimescaleDB - a PostgreSQL-powered time-series database.

In this talk, I will share with you the kinds of insights that can be unlocked from tracing data using SQL.

First, I'll provide a bit of context to make sure we are all up to speed.

What is a trace? 

If you have ever debugged an uncaught exception, you are likely familiar with a stacktrace. A stacktrace shows the path of function calls that were executed from the exception back to the main function. It "traces" the path of execution backwards.

A trace - or distributed trace - is similar. Traces are usually associated with a request, and they record the path of execution that within and among services to fullfill that request.

A trace is a tree structure in which each node is a span. A span can be thought of as a section of code that was executed. It has a start time and end time. A span can have child spans. The parent span's start and end times encompass all of the children.

A trace is both a tree structure, and a time-series.

Okay, that was a super quick rundown of tracing, but hopefully enough to get us all on the same page. If you're still fuzzy, it should become more clear as we move forward.

So, what is OpenTelemetry? It is an CNCF-backed project
providing open tools, APIs, SDKs, and line-protocols for traces, metrics, and logs. The goal of OpenTelemetry is to create an ecosystem of interoperable and interchangable observability tools.

Imagine a set of microservices interacting. They are instrumented with metrics, logs, and tracing. Typically, I'd imagine that alarms are set on metrics. An alarm is triggered, you check relevant dashboards, then you dig around through logs to find messages that hopefully correlate, and hopefully those logs contain trace ids. Then, you may take a sample of these trace ids and go look at those traces one by one to see whether they shed light on the issue.

My guess is that this is typically how traces are used.

Here is a single trace as visualized in Jaeger.

This trace was generated by an example system built for this talk. It is an absurd little system that generates passwords using five microservices.
1 generates random digits
1 generates random special chars
1 generates random lowercase chars
1 generates random uppercase chars
1 uses the others to build a random password

These services are instrumented ONLY with tracing.
No metrics
No logs

The traces are sent to an instance of the open telemetry collector which forwards them to promscale where they are inserted into the database.

We are going to be looking at a single view, and only a handful of columns in that view. Just scratching the service of what can be done.

I am going to show you a series of SQL queries and Grafana dashboards. We'll start with some simple ones and work up to some impressive ones that show the immense value of using SQL to analyze traces.

Here is the view's definition.







